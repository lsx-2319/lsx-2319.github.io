[{"content":"组播 IGMP 协议详解\n在日常的网络传输中，我们最常听到的就是 单播（Unicast） 和 广播（Broadcast）。单播就像你给朋友单独发一条微信，只发给他一个人；广播则像在微信群里吼一嗓子，所有人都能看到。\n那 组播（Multicast） 呢？它更像是建立一个兴趣小组，只有加入这个小组的人才能收到你发的内容。而 IGMP（Internet Group Management Protocol）就是负责“管理小组成员”的协议。\n一、IGMP 是什么？ IGMP（Internet Group Management Protocol） 是 IPv4 网络中用于管理组播组成员关系的协议。\n简单来说，它帮助网络设备（尤其是路由器）知道：\n哪些主机想加入某个组播组 哪些主机不再需要组播数据 当前有哪些活跃的组播成员 它工作在 网络层，但运行在主机和相邻路由器之间，并不会跨越多个路由器去传播。\n二、组播的实际例子 想象一下，你所在的公司要直播一场全员大会。\n如果用单播，每个员工的电脑都要跟服务器建立一条独立的连接，这会让服务器压力山大。 如果用广播，虽然省事，但不仅公司员工，连打印机、考勤机这些设备也会被迫收到直播数据（没用还浪费带宽）。 用组播就完美了：只有主动“加入直播组”的员工电脑才能收到直播视频数据，其他设备完全不受影响。 这个“加入直播组”的过程，就是通过 IGMP 协议 来实现的。\n三、IGMP 的工作机制 IGMP 的运作过程，核心就是三种报文：\nMembership Query（成员查询）\n由路由器发出，询问“大家谁还在某个组播组里？” Membership Report（成员报告）\n由主机发出，表示“我还在某个组里，请继续给我发数据。” Leave Group（离开组）\n由主机发出，表示“我不看这个组播数据了，可以停了。” 四、IGMP 的版本演进 IGMP 目前有三个版本，每一代都比上一代更智能。\nIGMPv1（最基础） 主机可以加入组播组，但没有“离开组”的机制，需要路由器超时后才会停止发送数据。 IGMPv2（更高效） 增加了 Leave Group 报文，可以主动告诉路由器自己不再需要数据。 支持指定组的查询，提高了管理效率。 IGMPv3（更灵活） 支持 源特定组播（SSM），即只接收来自特定源 IP 的组播数据，安全性和精准度更高。 五、用例场景再深入一点 我们回到公司的直播例子。\n假设公司 IT 部署了组播路由器，并分配了一个组播地址 239.1.1.1 作为“全员大会直播”频道：\n当你打开直播软件时，软件会通过 IGMP Report 告诉路由器： “我要加入 239.1.1.1 组，请把数据发给我。”\n路由器记录下来，并把直播视频数据转发到你的电脑。 当直播结束，你关闭软件，软件会发一个 Leave Group 给路由器： “我退出 239.1.1.1 组了，可以停发给我。”\n如果有很多人退出，路由器可能会发 Membership Query 确认是否还有人需要这个直播数据，如果没人了，就停止该组播数据的转发。 这样一来，服务器只需要发一份直播流到路由器，路由器再复制给组内成员，比单播节省了大量带宽，也避免广播的无差别轰炸。\n六、IGMP 与其他协议的关系 IGMP 只是组播管理的**“前台登记员”**，真正负责组播转发的，是像 PIM（Protocol Independent Multicast） 这样的路由协议。\n可以这么理解：\nIGMP：负责“谁在看这个频道” PIM：负责“把频道信号送到这些人手里” 两者配合，才能让组播数据准确高效地送达。\n七、总结 IGMP 协议虽然听起来是个小角色，但在组播体系中它就像一个观众登记系统：\n它让路由器知道谁需要组播数据，谁已经离开 它帮助节省带宽、减少无效数据传输 它的版本升级让组播管理更加高效和安全 下一次你在公司看直播、在局域网玩联机游戏、或者家里 IPTV 看电视时，很可能后台就有 IGMP 在悄悄帮你管理数据流。\n所以，虽然它的存在感不高，但没有它，组播的世界就会变得一团糟。\n","date":"2025-08-09T00:00:00Z","permalink":"https://example.com/p/%E7%BB%84%E6%92%ADigmp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","title":"组播igmp协议详解"},{"content":"好的，我们来详细解析一下 OSPF（Open Shortest Path First） 协议。它是网络协议栈中非常重要的内部网关协议（IGP），用于在单一自治系统（AS） 内部的路由器之间动态地交换路由信息并计算最优路径。\n核心定位与目标 类型： 链路状态路由协议（Link-State Routing Protocol）。这是理解 OSPF 的关键。 目标： 让 AS 内部的所有路由器都拥有一张完全相同的、描述整个 AS 网络拓扑结构的“地图”（链路状态数据库 - LSDB），并基于此地图独立地使用 SPF（Shortest Path First，即 Dijkstra）算法 计算出到达 AS 内所有网络的最短（最优）路径树，最终形成路由表。 对比 RIP： 相比距离矢量协议（如 RIP），OSPF 收敛速度快得多（网络变化时路由信息快速稳定），支持大型网络（通过区域划分），无路由环路（由 SPF 算法保证），支持 VLSM 和 CIDR，提供更丰富的路由度量（Cost）。 关键特性和概念 链路状态（Link-State）：\n每个路由器不再像 RIP 那样只告诉邻居“我到某个网络的距离是多少”，而是主动描述自己直连的网络状态。 这个描述信息称为 LSA（Link State Advertisement - 链路状态通告）。它包含的信息如：该路由器连接了哪些网络、邻居路由器是谁、连接到这些链路/邻居的“代价（Cost）”是多少。 路由器将生成的 LSA 泛洪（Flooding） 给 OSPF 域内的所有其他路由器（在区域限制内）。 链路状态数据库（LSDB - Link State Database）：\n每个路由器收到域内所有其他路由器发来的 LSA 后，会把这些 LSA 存储在自己的 LSDB 中。 理想情况下，同一个区域（Area）内所有路由器的 LSDB 内容是完全一致的。这是路由器能独立、一致地计算最短路径树的基础。 SPF（Dijkstra）算法：\n每个路由器都独立地以自己的视角（作为根）运行 SPF 算法。 算法基于 LSDB 中存储的完整拓扑信息（节点=路由器/网络，边=链路，边权=Cost），计算出一棵到达所有目标网络的最短路径树（SPT - Shortest Path Tree）。 这棵树上的路径就是该路由器认为的到达各网络的最优无环路径。 计算完成后，最优路径被安装到路由表中。 区域（Area）划分：\n为了解决大型网络 LSDB 过大、SPF 计算负担过重、LSA 泛洪范围过广的问题，OSPF 引入了层次化结构 - 区域。 骨干区域（Area 0）： OSPF 域的核心。所有其他区域（非骨干区域）必须直接连接到骨干区域。骨干区域负责在非骨干区域之间传递路由信息。区域 0 的 LSDB 包含所有区域的汇总路由信息。 非骨干区域（Area 1, Area 2, etc）： 内部路由器的 LSDB 只包含本区域的详细拓扑信息和来自其他区域的汇总路由信息（由 ABR 生成）。这大大减小了 LSDB 的规模，限制了 LSA 泛洪的范围，提高了网络的扩展性和稳定性。 区域边界路由器（ABR - Area Border Router）： 连接多个区域（至少一个区域是 Area 0）的路由器。它负责： 将其连接区域的内部路由信息汇总后通告到骨干区域。 将骨干区域学到的其他区域的汇总路由信息（以及外部路由）通告到其连接的非骨干区域。 维护所连接每个区域的独立 LSDB。 邻居和邻接关系建立：\n邻居（Neighbor）： 通过 Hello 协议发现的、连接在同一链路上的其他 OSPF 路由器。两台路由器交换 Hello 包，确认参数（如 Area ID, Hello/Dead Interval, 认证密码等）匹配后成为邻居。 邻接（Adjacency）： 在邻居关系基础上，需要同步 LSDB 的路由器对之间建立邻接关系。只有建立了邻接关系的路由器才会交换 LSA。 建立过程关键状态： Down -\u0026gt; Init： 收到邻居的 Hello 包（包中没有包含自己的 Router ID）。 Init -\u0026gt; 2-Way： 收到邻居的 Hello 包（包中已包含自己的 Router ID）。选举 DR/BDR（如果需要）。 2-Way -\u0026gt; ExStart： （仅与 DR/BDR 或点对点链路上的邻居）协商主从关系和初始 DD 序列号。 ExStart -\u0026gt; Exchange： 交换 DBD 包（Database Description），描述自己 LSDB 的摘要（LSA 头部）。 Exchange -\u0026gt; Loading： 通过 LSR（Link State Request）请求和 LSU（Link State Update）发送自己缺少的或更新的完整 LSA。 Loading -\u0026gt; Full： LSDB 同步完成，邻接关系建立成功。开始定期发送 Hello 包维护邻居关系，并泛洪 LSA 更新。 OSPF 工作流程概览 启动与邻居发现： 路由器在接口启用 OSPF，开始发送 Hello 包。发现邻居。 邻接关系建立与 LSDB 同步： 与符合条件的邻居（如 DR/BDR 或点对点邻居）建立邻接，交换 DBD、LSR、LSU 包，同步 LSDB。 维护 LSDB： 当本地链路状态发生变化（如接口 Up/Down，Cost 改变），路由器产生新的 LSA。 新的 LSA 被泛洪给所有建立了邻接关系的邻居。 邻居收到新 LSA 后，更新自己的 LSDB，并继续泛洪（除始发路由器外），同时立即触发一次 SPF 计算（部分计算或完全计算，取决于 LSA 类型）。 定期发送 LSA（老化时间默认为 30 分钟），收到后会刷新老化计时器。 路由计算： 路由器使用 SPF 算法基于最新的 LSDB 计算最短路径树，将最优路径安装到路由表中。 维护邻居关系： 通过周期性的 Hello 包（默认 10 秒/30 秒 Dead）维护邻居关系。若在 Dead Interval 内未收到邻居的 Hello 包，则认为邻居失效，清除邻接关系，移除该邻居产生的 LSA，触发新的 SPF 计算。 总结 OSPF 是一个强大、复杂且高度可扩展的链路状态内部网关协议。其核心在于每个路由器都拥有相同的网络拓扑地图（LSDB），并独立运行 SPF 算法计算无环的最短路径。通过区域划分解决了大型网络的可扩展性问题。理解 LSA 的类型和作用、邻居/邻接建立过程、DR/BDR 角色、区域概念（尤其是 Area 0）以及 SPF 计算原理是掌握 OSPF 的关键。虽然配置和设计比 RIP 复杂，但其快速收敛、无环、可扩展的特性使其成为现代企业网和数据中心内部网络路由的首选协议之一。\n","date":"2025-07-29T00:00:00Z","permalink":"https://example.com/p/ospf%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","title":"OSPF协议详解"},{"content":"RoCE 什么是RoCE？ 全称RDMA over Converged Ethernet，RoCE是一种基于以太网的远程直接内存访问（RDMA）技术，旨在通过优化协议栈和硬件卸载，实现高性能、低延迟的数据传输。其核心是通过绕过操作系统内核，减少数据复制和CPU开销，尤其适用于AI训练、超算和分布式存储等场景。\n从 2010 年开始，RMDA 开始引起越来越多的关注，当时IBTA发布了第一个在融合以太网 (RoCE) 上运行 RMDA 的规范。然而，最初的规范将 RoCE 部署限制在单个第 2 层域，因为 RoCE 封装帧没有路由功能。2014 年，IBTA 发布了 RoCEv2，它更新了最初的 RoCE 规范以支持跨第 3 层网络的路由，使其更适合超大规模数据中心网络和企业数据中心等。\nRoCEv1 2010年4月，IBTA发布了RoCE，此标准是作为Infiniband Architecture Specification的附加件发布的，所以也称为IBoE（InfiniBand over Ethernet）。这时的RoCE标准是在以太链路层之上用IB网络层代替了TCP/IP网络层，所以不支持IP路由功能。RoCE V1协议在以太层的typeID是0x8915。\n在RoCE中，infiniband的链路层协议头被去掉，用来表示地址的GUID被转换成以太网的MAC。Infiniband依赖于无损的物理传输，RoCE也同样依赖于无损的以太传输，这一要求会给以太网的部署带来了成本和管理上的开销。\n以太网的无损传输必须依靠L2的QoS支持，比如PFC(Priority Flow Control)，接收端在buffer池超过阈值时会向发送方发出pause帧，发送方MAC层在收到pause帧后，自动降低发送速率。这一要求，意味着整个传输环节上的所有节点包括end、switch、router，都必须全部支持L2 QoS，否则链路上的PFC就不能在两端发挥有效作用。\nRoCEv2 由于RoCEv1的数据帧不带IP头部，所以只能在L2子网内通信。为了解决此问题，IBTA于2014年提出了RoCE V2，RoCEv2扩展了RoCEv1，将GRH(Global Routing Header)换成UDP header +　IP header，扩展后的帧结构如下图所示。\n针对RoCE v1和RoCE v2，以下两点值得注意：\nRoCE v1(Layer 2)运作在Ethernet Link Layer(Layer 2)所以Ethertype 0x8915，所以正常的Frame大小为1500 bytes，而Jumbo Frame则是9000 bytes。 RoCE v2(Layer 3)运作在UDP/IPv4或UDP/IPv6之上(Layer 3)，采用UDP Port 4791进行传输。因为 RoCE v2的封包是在 Layer 3上可进行路由，所以有时又会称为Routable RoCE或简称RRoCE。 RoCEv2的普及性 生态成熟度：国内云计算与AI企业（如阿里云、腾讯云、华为云）普遍采用RoCEv2，因其兼容现有以太网架构且性价比高。例如，华为鲲鹏920芯片已支持100Gbps RoCE，并在数据中心部署中实现端到端延迟5-10μs。\n应用场景：大规模AI训练（如千卡级集群）和分布式存储（如EMC Isilon）通过RoCEv2优化通信效率，实际带宽利用率达90%以上（400G以太网实测360Gbps）。\n对比InfiniBand 维度 RoCEv2 InfiniBand 协议栈 基于UDP/IP的以太网扩展 专用协议栈（物理层到传输层独立设计） 部署成本 利用现有以太网设备，成本低 需专用交换机和网卡，成本高 扩展性 支持三层路由，扩展性强 依赖子网管理器（SM），集中式管理 性能 延迟略高（微秒级），吞吐量接近IB 超低延迟（纳秒级），吞吐量更高 适用场景 通用数据中心、云计算、AI训练 超算中心、极致性能要求的HPC环境 ","date":"2025-07-22T00:00:00Z","permalink":"https://example.com/p/roce%E4%BB%8B%E7%BB%8D/","title":"Roce介绍"},{"content":"BGP协议\n1、什么是bgp路由协议 BGP是一种基于距离矢量的路由协议，用于实现不同AS之间的路由可达。\nBGP协议的基本特点：\n（1）BGP是一种外部网关协议，其着眼点不在于发现和计算路由，而在于控制路由的传播和选择最佳路由；\n（2）BGP使用TCP作为其传输层协议（端口号179）,提高了协议的可靠性； （3）BGP是一种距离矢量路由协议，在设计上就避免了环路的发生；\n（4）BGP提供了丰富的路由策略，能够实现路由的灵活过滤和选择； （5）BGP采用触发式增量更新，而不是周期性的更新；\n2、如何建立bgp对等体 （1）TCP连接建立\n（2）BGP路由器发送OPEN报文协商参数\n（3）BGP路由器发送keepalive报文完成对等体建立\n（4）参数协商正常后双方相互发送keepalive报文，收到对方的keepalive报文后对等体建立成功，同时后续定期发送keepalive报文用于保持连接。\n（5）BGP对等体关系建立好了，就可以通过BGP update 报文通告路由到对等体。收到对方的keepalive报文后对等体建立成功，同时后续定期发送keepalive报文用于保持连接。 3、bgp的报文类型 4、bgp状态变化 （1）Idle状态是BGP初始状态。\n在Idle状态下，BGP拒绝对等体发送的连接请求。只有在收到本设备的Start事件后，BGP才开始尝试和其它BGP对等体进行TCP连接，并转至Connect状态。\nStart事件是由一个操作者配置一个BGP过程，或者重置一个已经存在的过程或者路由器软件重置BGP过程引起的。\n任何状态中收到Notification报文或TCP拆链通知等Error事件后，BGP都会转至Idle状态。\n（2）Connect状态\n在Connect状态下，BGP启动连接重传定时器（Connect Retry），等待TCP完成连接。\n如果TCP连接成功，那么BGP向对等体发送Open报文，并转至OpenSent状态。 如果TCP连接失败，那么BGP转至Active状态。 如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP继续尝试和其它BGP对等体进行TCP连接，停留在Connect状态。 （3）Active状态\n在Active状态下，BGP总是在试图建立TCP连接。\n如果TCP连接成功，那么BGP向对等体发送Open报文，关闭连接重传定时器，并转至OpenSent状态。 如果TCP连接失败，那么BGP停留在Active状态。 如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP转至Connect状态。 （4）Opensent状态、openconfirm状态\nTCP三次握手建立成功后，发送open报文建立对等体关系，此时的状态为 opensent状态，当收到对端回应的open报文，并且参数检查无误，在发送keepalive报文后进入openconfirm状态。\n（5）established状态\n进入openconfirm状态后，收到对端的keepalive报文后进入established状态。\n5、bgp的路由生成 BGP路由是通过BGP命令通告而成的，而通告BGP路由的方法有两种：network和Import。 （1）network方式：\n使用network命令可以将当前设备路由表中的路由（非BGP）发布到BGP路由表中并通告给邻居，和OSPF中使用network命令的方式大同小异，只不过在BGP宣告时，只需要宣告网段+掩码数即可，如：network 12.12.0.0 16。\n（2）Import方式：\n使用Import命令可以将该路由器学到的路由信息重分发到BGP路由表中，是BGP宣告路由的一种方式，可以引入BGP的路由包括：直连路由、静态路由及动态路由协议学到的路由。其命令格式与在RIP中重分发OSPF差不多。\n6、BGP通告原则 BGP设备会将最优路由加入BGP路由表，形成BGP路由。\nBGP设备与对等体建立邻居关系后，采用以下交互原则： 从IBGP对等体获得的BGP路由，BGP设备只传递给它的EBGP对等体。 从EBGP对等体获得的BGP路由，BGP设备传递给它所有EBGP和IBGP对等体（对等体是IBGP只能传递一跳，对等体是EBGP则不限制） 当存在多条到达同一目的地址的有效路由时，BGP设备只将最优路由发布给对等体 路由更新时，BGP设备只发送更新的BGP路由 所有对等体发送的路由，BGP设备都会接收 所有EBGP对等体在传递过程中下一跳改变 所有IBGP对等体在传递过程中下一跳不变（需要特别注意） 默认EBGP传递时 TTL值为1（需要特别注意） 默认IBGP传递时 TTL值为255 ","date":"2025-07-16T14:05:05+08:00","permalink":"https://example.com/p/bgp%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/","title":"BGP协议介绍"},{"content":"1.客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。\n2.采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书，证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书 (当然了是要钱的，安全级别越高价格越贵)。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。\n3.服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息。\n4.客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。就像下面这样：\n如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。\n5.客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。\n6.服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。\n7.服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。\n8.双方使用对称加密愉快地传输所有数据。 ","date":"2025-07-13T14:27:57+08:00","permalink":"https://example.com/p/https%E7%9A%84%E5%8E%9F%E7%90%86/","title":"Https的原理"},{"content":"Felix：运行在每一台 Host 的 agent 进程，主要负责网络接口管理和监听、路由、ARP 管理、ACL 管理和同步、状态上报等。\netcd：分布式键值存储，主要负责网络元数据一致性，确保 Calico 网络状态的准确性，可以与 kubernetes 共用；\nBGP Client（BIRD）：Calico 为每一台 Host 部署一个 BGP Client，使用 BIRD 实现，BIRD 是一个单独的持续发展的项目，实现了众多动态路由协议比如 BGP、OSPF、RIP 等。在 Calico 的角色是监听 Host 上由 Felix 注入的路由信息，然后通过 BGP 协议广播告诉剩余 Host 节点，从而实现网络互通。\nBGP Route Reflector：在大型网络规模中，如果仅仅使用 BGP client 形成 mesh 全网互联的方案就会导致规模限制，因为所有节点之间俩俩互联，需要 N^2 个连接，为了解决这个规模问题，可以采用 BGP 的 Router Reflector 的方法，使所有 BGP Client 仅与特定 RR 节点互联并做路由同步，从而大大减少连接数。\nCalico API Server 可以使用 kubectl 直接管理 Calico。\nFelix Felix 以 agent 代理的形式在每台机器端点上运行。对路由和 ACL 以及主机编程，为该主机上的端点提供所需的连接。\n根据具体的编排器环境，Felix 负责：\n接口管理\n将有关接口的信息编入内核，以便内核能够正确处理来自该端点的流量。特别是，确保主机响应来自每个工作负载的 ARP 请求，提供主机的 MAC，并为它所管理的接口启用 IP 转发。它还监控接口，以确保编程在适当的时候应用。\n路由编程\n将其主机上的端点的路由编程到 Linux 内核的 FIB（转发信息库）。这可以确保到达主机上的以这些端点为目的地的数据包被相应地转发。\nACL 编程\n在 Linux 内核中编程 ACL，以确保只有有效的流量可以在端点之间发送，并且端点不能规避 Calico 的安全措施。\n状态报告\n提供网络健康数据。特别是在配置其主机时报告错误和问题。这些数据被写入数据存储，以便对网络的其他组件和运营商可见。\nBIRD BGP Internet Routing Daemon，简称 BIRD。从 Felix 获取路由，并分发到网络上的 BGP peer，用于主机间的路由。在每个 Felix 代理的节点上运行。\nBGP 客户端负责：\n路由分配\n当 Felix 将路由插入 Linux 内核的 FIB 时，BGP 客户端将它们分配给部署中的其他节点。这确保了部署中的有效流量路由。\nBGP 路由反射器的配置\nBGP 路由反射器通常是为大型部署而配置的，而不是一个标准的 BGP 客户端。BGP 路由反射器作为连接 BGP 客户端的一个中心点。(标准 BGP 要求每个 BGP 客户端在网状拓扑结构中与其他每个 BGP 客户端连接，这很难维护)。\n为了实现冗余，你可以无缝部署多个 BGP 路由反射器。BGP 路由反射器只参与网络的控制：没有终端数据通过它们。当 Calico BGP 客户端将其 FIB 中的路由通告给路由反射器时，路由反射器将这些路由通告给部署中的其他节点。\nconfd 开源的、轻量级的配置管理工具。监控 Calico 数据存储对 BGP 配置和全局默认的日志变更，如 AS 号、日志级别和 IPAM 信息。\nConfd 根据存储中的数据更新，动态生成 BIRD 配置文件。当配置文件发生变化时，confd 会触发 BIRD 加载新的文件。\n","date":"2025-07-12T14:46:36+08:00","permalink":"https://example.com/p/calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/","title":"Calico网络插件介绍"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://example.com/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://example.com/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]